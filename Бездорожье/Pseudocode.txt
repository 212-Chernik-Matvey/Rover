Определить функцию findShortestPath с параметрами start и end:

Установить веса ребер графа с использованием метода Give_Graph_Weight()
Установить расстояние от узла start равным 0
Создать приоритетную очередь пар, где первый элемент - это расстояние, а второй элемент - узел
Поместить {0, start} в очередь
Пока очередь не пуста:

Извлечь верхнюю пару из очереди и установить dist как первый элемент, а u как второй элемент
Если абсолютное значение разницы между distance[u] и dist больше небольшого значения eps, перейти к следующей итерации
Для каждого соседнего узла v узла u:

Если абсолютное значение graph[u][v] + 1 меньше небольшого значения eps, перейти к следующей итерации
Вычислить альтернативное расстояние alt как distance[u] + graph[u][v]
Если абсолютное значение distance[v] + 1 меньше небольшого значения eps или alt меньше distance[v]:
Установить distance[v] как alt
Установить path[v] как u
Поместить {alt, v} в очередь
Создать пустой вектор shortestPath

Установить current как end
Пока current не равен -1:
Поместить current в shortestPath
Установить current как path[current]
Развернуть shortestPath
Вернуть shortestPath

Определить функцию Ways_doer:

Преобразовать точки A и B в узлы start и end с помощью метода Code_point
Вызвать метод findShortestPath с параметрами start и end и сохранить результат в graph_peaks
Создать пустой вектор real_way

Для каждого значения k в graph_peaks:
Декодировать координаты k с помощью метода decoder и сохранить результат в cordinate
Добавить f->Field[cordinate.first][cordinate.second] в real_way
Вернуть real_way